<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fang Yongchao</title>
    <link>https://fanggong.pub/</link>
    <description>Recent content on Fang Yongchao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ch</language>
    <lastBuildDate>Sun, 18 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://fanggong.pub/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Projects</title>
      <link>https://fanggong.pub/projects/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/projects/</guid>
      <description>描述性分析和可视化APPdeveloping…
</description>
    </item>
    
    <item>
      <title>特征工程中常用到的几个概念</title>
      <link>https://fanggong.pub/posts/20210418_concepts_about_feature_selection/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210418_concepts_about_feature_selection/</guid>
      <description>信息熵(Entropy)条件熵(Conditional Entropy)信息增益(Information Gain, IG)互信息(Mutual Infomation, MI)证据权重(Weight of Evidence, WOE)信息值(Information Value, IV)群体稳定性指标(Population Stability Index, PSI)信息熵(Entropy)对于系统内的多个事件\(\boldsymbol{E} = \{ E_1, E_2, ..., E_n \}\)，其发生的概率为\(\boldsymbol{P} = \{ p_1, p_2, ..., p_n \}\)，熵的定义为：\[\Eta(X) = -\sum_i p_i\log_b(p_i)\]根据对数的底\(b\)的不同，熵的单位不同。
熵被认为是不确定性的度量。很显然当系统内只有一个事件且该事件必定发生时，熵取最小值为0。当系统内各事件发生概率相同时，熵取最大值\(\log_bn\)，此时系统内的不确定性最高。特别的，当\(p_i\)为0时，\(p_i \log_b(p_i)\)为0。
条件熵(Conditional Entropy)条件熵表示基于某条件下的信息熵。定义为：\[\Eta(Y|X) = \sum_ip(x_i)\Eta(Y|X = x_i)\]这里的\(\Eta(Y|X = x_i)\)为\(X\)取\(x_i\)时，\(Y\)的信息熵。
信息增益(Information Gain, IG)信息增益等于信息熵减去条件熵。即：\[IG(Y, X) = \Eta(Y) - \Eta(Y|X)\]可以理解为在知道变量\(X\)后，\(Y\)的不确定性减少了多少。</description>
    </item>
    
    <item>
      <title>git配置及操作</title>
      <link>https://fanggong.pub/posts/20210408_git/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210408_git/</guid>
      <description></description>
    </item>
    
    <item>
      <title>生存分析及R语言实现</title>
      <link>https://fanggong.pub/posts/20210406_survival_analysis/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210406_survival_analysis/</guid>
      <description>相关概念Kaplan-Meier方法Log-rank检验Cox比例风险回归模型相关包：survival，survminer
相关概念生存分析主要用于分析感兴趣的事件发生所需要的时间以及变量对事件发生的影响。
有如下几个相关概念：
事件（Event）：比如在癌症相关研究中，病人的死亡
时间（Time）：当事件没有发生时，时间就是起始时间到当前时间的跨度，当事件发生时，时间为起始时间到事件发生的时间跨度
删失（Censoring）：个人认为这个概念没必要过度理解，截止到某时间点事件没有发生，即为删失（这个时间点可能是当前时间，也可能是失去调查对象数据的中间某个时间点）
生存函数（Survival Function）：一般写作\(S(t)\)，表示从起始时间到时间t没有发生事件的概率，即：\[S(t) = P \left( T &amp;gt; t \right)\]
寿命分布函数（Lifetime distribution function）：一般写作\(F(t)\)，表示从起始时间到时间t发生了事件的概率，即：\[F(t) = P \left( T \le t \right) = 1 - S(t)\]
危险函数（Harzard Function）：一般写作\(h(t)\)或\(\lambda(t)\)，表示在截止到时间t事件都没有发生的条件下，事件接下来发生的瞬时概率，即：\[h(t) = \lim_{\Delta t \to 0} {P(t \le T \lt t + \Delta t\,|\, T &amp;gt; t) \over {\Delta t}} = {F&amp;#39;(t) \over S(t)} = - {S&amp;#39;(t) \over S(t)}\]</description>
    </item>
    
    <item>
      <title>对本主题的样式的测试</title>
      <link>https://fanggong.pub/posts/always_today/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/always_today/</guid>
      <description>任何做个人博客的人应该都过不了对样式无穷无尽的修改这个坎吧…
这是一级标题这是二级标题这是三级标题页内跳转点这里跳到样式——表格点着里跳到样式——iframe无序列表御田的决心！白胡子的试炼!白胡子的弟弟！御田的大冒险兵刃相接！罗杰与白胡子！有序列表新的同盟！？凯多军大集结决战迫近！草帽一伙进入战斗状态大新闻！七武海袭击事件嵌套列表元气森林0糖0脂肪0卡路里代码块height &amp;lt;- rnorm(100, 170, 8)weight &amp;lt;- rnorm(100, 70, 12)t.test(height, weight)## ## Welch Two Sample t-test## ## data: height and weight## t = 73.683, df = 170.43, p-value &amp;lt; 2.</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（8）—— Labels</title>
      <link>https://fanggong.pub/posts/20210330_ggplot2_labels/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210330_ggplot2_labels/</guid>
      <description>labs()：添加各种主副标题annotate()：添加注释labs()：添加各种主副标题ggplot(tibble(long = rnorm(100), lat = rnorm(100))) + geom_point(aes(x = long, y = lat)) +labs(x = &amp;quot;This is x-axis label&amp;quot;, y = &amp;quot;This is y-axis label&amp;quot;,title = &amp;quot;This is the title&amp;quot;,subtitle = &amp;quot;This is the subtitle&amp;quot;,caption = &amp;quot;This is the caption&amp;quot;,tag = &amp;quot;This is tag&amp;quot;)annotate()：添加注释ggplot(tibble(long = rnorm(100), lat = rnorm(100))) + geom_point(aes(x = long, y = lat)) +annotate(geom = &amp;quot;text&amp;quot;, x = 0, y = 0, label = &amp;quot;This is the annotation&amp;quot;, color = &amp;quot;blue&amp;quot;)</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（7）—— Faceting</title>
      <link>https://fanggong.pub/posts/20210329_ggplot2_faceting/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210329_ggplot2_faceting/</guid>
      <description>facet_grid()facet_wrap()分面函数&amp;lt;FACET_FUNCTION&amp;gt;提供了两种分面方式，第一种是网格式的分面facet_grid()，另一种facet_wrap()可以理解为将多个图按从左至右从上至下的顺序放入设计好的网格中。
facet_grid()ggplot(mpg, aes(cty, hwy)) + geom_point() + facet_grid(rows = vars(year), cols = vars(fl))facet_wrap()ggplot(mpg, aes(cty, hwy)) + facet_wrap(vars(fl), nrow = 3)</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（6）—— Themes</title>
      <link>https://fanggong.pub/posts/20210327_ggplot2_themes/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210327_ggplot2_themes/</guid>
      <description>完整主题直接修改当前主题主题函数&amp;lt;THEME_FUNCTION&amp;gt;包括ggplot2中自带的一些完整主题，以及对当前主题进行直接修改的函数。
完整主题theme_bw()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_bw()theme_gray()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_gray()theme_dark()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_dark()theme_classic()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_classic()theme_light()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_light()theme_linedraw()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_linedraw()theme_minimal()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_minimal()theme_void()ggplot(mpg) + geom_point(aes(x = class, y = hwy, color = trans)) +theme_void()直接修改当前主题</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（5）—— Position</title>
      <link>https://fanggong.pub/posts/20210326_ggplot2_position/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210326_ggplot2_position/</guid>
      <description>position = &#34;dodge&#34;：并排摆放position = &#34;fill&#34;：填充摆放position = &#34;jitter&#34;：抖动点position = &#34;stack&#34;：堆栈摆放position = &#34;jitterdodge&#34;：不是很明白实际意义&amp;lt;POSITION_FUNCTION&amp;gt;函数作为&amp;lt;STAT_FUNCTION&amp;gt;和&amp;lt;GEOM_FUNCTION&amp;gt;函数的参数使用。
position = &#34;dodge&#34;：并排摆放ggplot(mpg, aes(fl, fill = drv)) + geom_bar(position = position_dodge()) + scale_fill_brewer(palette = 1)position = &#34;fill&#34;：填充摆放ggplot(mpg, aes(fl, fill = drv)) + geom_bar(position = position_fill()) + scale_fill_brewer(palette = 1)position = &#34;jitter&#34;：抖动点ggplot(mpg, aes(cty, hwy)) + geom_point(position = position_jitter(), size = 1, alpha = 0.</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（4）—— Coordinate</title>
      <link>https://fanggong.pub/posts/20210325_ggplot2_coordinate/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210325_ggplot2_coordinate/</guid>
      <description>coord_cartesian()：更改笛卡尔坐标系的显示范围coord_fixed()：更改x轴和y轴的坐标比例coord_flip()：翻转坐标轴coord_polar()：将笛卡尔坐标转换成极坐标coord_trans()：进行坐标变换坐标轴函数&amp;lt;COORDINATE_FUNCTION&amp;gt;很少，个人觉得使用思路也相当清晰。
coord_cartesian()：更改笛卡尔坐标系的显示范围coord_cartesian()的作用是显示图的某一部分，并不会减少使用的数据xlim，ylim：控制x轴和y轴的范围ggplot(tibble(lat = rnorm(100), long = rnorm(100))) + geom_point(aes(x = lat, y = long)) +coord_cartesian(xlim = c(0, 5))coord_fixed()：更改x轴和y轴的坐标比例ratio：同样的数值在坐标轴上的长度y轴是x轴的ratio倍xlim，ylim：控制x轴和y轴的范围ggplot(tibble(long = 1:10, lat = 1:10*2)) +geom_point(aes(x = long, y = lat)) +coord_fixed(ratio = 1/2)coord_flip()：翻转坐标轴xlim，ylim：控制x轴和y轴的范围ggplot(tibble(letter = sample(LETTERS[1:10], 200, replace = TRUE))) +geom_bar(aes(x = letter)) +coord_flip()coord_polar()：将笛卡尔坐标转换成极坐标theta：选择哪个轴变为极坐标的thetastart：弧度，一圆周为\(2\pi\)弧度direction：1为顺时针，-1为逆时针可以通过这个函数完成很多骚操作ggplot(tibble(letter = sample(LETTERS[1:10], 200, replace = TRUE))) +geom_bar(aes(x = letter)) +coord_polar(theta = &amp;quot;x&amp;quot;, start = pi, direction = -1)coord_trans()：进行坐标变换xlim，ylim：控制x轴和y轴的范围文档中说coord_trans()函数不同于标度变换，但是用起来感觉就是一个东西ggplot(data.</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（3）—— Scales</title>
      <link>https://fanggong.pub/posts/20210324_ggplot2_scales/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210324_ggplot2_scales/</guid>
      <description>对连续型数据的坐标轴进行修改对离散型数据的坐标轴进行修改对时间序列数据的坐标轴进行修改TODO标度函数&amp;lt;SCALE_FUNCTION&amp;gt;应该是最麻烦的部分了，可以放进aes()函数中的元素都可以通过标度函数进行调整修改，只是所有的调整和修改改变的都是图形展示出来的样子，其背后的数据并没有做出任何改变。
对连续型数据的坐标轴进行修改相关函数包括scale_x_continuous()和scale_y_continuous()
name：坐标轴名称breaks：坐标轴主要刻度线，可以为一个向量，也可以是一个函数，函数将limits作为输入，输出一个向量作为breaks，需要注意如果使用函数输出结果貌似会受到expand参数的影响，具体影响不明minor_breaks：坐标轴次要刻度线，具体同breakslabels：坐标轴各个break点的labels，可以为一个向量，也可以是一个函数，函数将breaks作为输入，输出一个向量作为labelslimits：坐标轴范围，可以是一个长度为2的向量，也可以是一个函数，当前默认的的limits作为输入，输出新的limitsexpand：对当前的坐标轴进行一定程度扩充，用expansion()对其进行赋值mult：上下（左右）各增加当前limits的mult倍add：上下（左右）各增加add长度的坐标轴trans：直接对坐标轴进行变换，有“asn”, “atanh”, “boxcox”, “date”, “exp”, “hms”, “identity”, “log”, “log10”, “log1p”, “log2”, “logit”, “modulus”, “probability”, “probit”, “pseudo_log”, “reciprocal”, “reverse”, “sqrt” 和 “time”position：坐标轴位置，“left”，“right”，“bottom”或“right”sec.axis：增加副坐标轴，用sec.axis()对其进行赋值trans：一个对主坐标进行变换的公式name：名称breaks：主要刻度线labels：标签scale_*_log10()，scale_*_reverse()，scale_x_sqrt()提供了三种常见变换的简写通过调整数据和sec.axis可以实现双坐标轴dat &amp;lt;- tibble(Month = c(1:12), Sales = sample(1:12),CumSales = cumsum(Sales))ggplot(dat, aes(Month, Sales)) +geom_col(fill = &amp;quot;blue&amp;quot;, alpha = 0.</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（2）—— Stat和Geom</title>
      <link>https://fanggong.pub/posts/20210323_ggplot2_stat_geom/</link>
      <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210323_ggplot2_stat_geom/</guid>
      <description>对连续变量x的各区间的样本数量进行统计作图对离散变量x的各类别数量进行统计作图计算连续变量x的密度曲线并作图对区域中点的数量进行统计作图对x，y作分位数回归并作图计算并绘制x，y的拟合曲线在离散变量x的各类别上对连续变量y进行统计作图计算连续变量y的密度曲线并作图对每个点上点的数量进行统计作图计算并绘制等高线在x上对y进行summary并作图在x和y上对z进行summary并作图通过x和函数fun()计算y=fun(x)并绘制曲线计算并绘制x的经验累计分布函数计算并绘制Q-Q图二维核密度估计并作图绘制空的坐标系绘制带箭头曲线/直线绘制折线绘制多边形绘制长方形绘制区域绘制直线添加标签/文本绘制偏离原位置的点绘制散点图在图的四周绘制点的一维投影绘制区间绘制地图绘制点阵图不明白作用的函数以下是一些个人看法。
ggplot2中以geom开头的函数可以理解为作图函数，以stat开头的函数可以理解为统计变换函数。在大部分的情况下，作图函数和统计变换函数都是成对出现的，也就是说在geom函数中会有一个stat参数，而stat函数中也会有一个geom参数，从而可以通过geom或stat函数一次性达到对数据进行统计变换并作图的目的。这也是我在最初很迷这个包的原因，因为在一些很奇葩的搭配下可能会出现一些很有趣的图形，虽然图形并不一定有意义，但是思考这个图形背后形成的过程是一件很有意思的事情。
对连续变量x的各区间的样本数量进行统计作图aes()必须参数：x，y(count, density, ncount, ndensity)binwidth：每一个柱的宽度bins：柱的数量center、boundary：若center设为“t”，则有一根柱以“t”为中线；若boundary设为“t”，则有一根柱以“t”为边线breaks：直接设定每一根柱的边线位置，该参数会覆盖以上所有参数closed：若为“right”，处于交界处的值属于右边的柱子；若为“left”，处于交界处的值属于左边的柱子pad：是否在图的左右两侧加空白，若为TRUE，最后呈现的图从高度为0的柱开始到高度为0的柱结束x应该是连续的，离散的x使用stat_count()stat_bin()ggplot(mpg, aes(hwy)) + stat_bin(aes(y = ..density..), binwidth = 1, boundary = 0, pad = TRUE)geom_freqpoly()ggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth = 1)geom_histogram()ggplot(mpg, aes(hwy)) + geom_histogram(binwidth = 1, boundary = 0.</description>
    </item>
    
    <item>
      <title>ggplot2使用笔记（1）—— Basics</title>
      <link>https://fanggong.pub/posts/20210322_ggplot2_basics/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210322_ggplot2_basics/</guid>
      <description>这份笔记实际作于好几年前，那时候刚开始接触R语言作图，觉得base R的作图系统实在过于繁琐而且感觉缺少语法上的一致性。接触ggplot2后完全沉迷于它的简单与一致性，因为ggplot2没有对应的中文文档，于是学习过程中笔记记得极其详尽，有些地方甚至到了参数的细节。
但是现在再回头看，最近两年已经很少用这个包了，主要还是由于在做研究生毕业设计的时候需要对图进行一些细微处的调整，而ggplot2由于已经自成一个世界，这种微调操作就变得相当难搞（最近在学习d3，感觉base R作图系统和ggplot2的区别有点类似于d3和echarts）。还有另一个放弃ggplot2的原因就是，它的主题已经越来越不在我的审美上了…
一张图包括最基础的ggplot()，统计变换和作图函数&amp;lt;GEOM_FUNCTION&amp;gt;，坐标轴函数&amp;lt;COORDINATE_FUNCTION&amp;gt;，分面函数&amp;lt;FACET_FUNCTION&amp;gt;，标度函数&amp;lt;SCALE_FUNCTION&amp;gt;以及主题函数&amp;lt;THEME_FUNCTION&amp;gt;
# NOT RUNggplot(data = &amp;lt;DATA&amp;gt;) +&amp;lt;GEOM_FUNCTION&amp;gt;(mapping = aes(&amp;lt;MAPPING&amp;gt;), stat = &amp;lt;STAT&amp;gt;,position = &amp;lt;POSITION&amp;gt;) +&amp;lt;COORDINATE_FUNCTION&amp;gt; +&amp;lt;FACET_FUNCTION&amp;gt; +&amp;lt;SCALE_FUNCTION&amp;gt; +&amp;lt;THEME_FUNCTION&amp;gt;last_plot()返回最后一张图
# NOT RUNlast_plot()ggsave()保存图像
# NOT RUNggsave(&amp;quot;plot.png&amp;quot;, width = 5, height = 5)</description>
    </item>
    
    <item>
      <title>关于指数族的定义</title>
      <link>https://fanggong.pub/posts/20210322_exponential_family/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210322_exponential_family/</guid>
      <description>指数分布族伯努利分布的指数族形式正态分布的指数族形式分类分布的指数族形式指数分布族的概念主要应用于广义线性模型（GLM）。
指数分布族指数分布族（exponential family）的分布可以写成如下形式：
\[p(x|\eta) = h(x) g(\eta) \exp \left\{\eta^Tu(x)\right\}\]
\(\boldsymbol {\eta}\)为自然参数，是决定分布的具体参数\(\boldsymbol {u(x)}\)称作充分统计量，通常有\(\boldsymbol {u(x) = x}\)\(\boldsymbol {g(\eta)}\)称作分布正规化系数，为确保概率和为1伯努利分布的指数族形式伯努利分布的一般形式可以写为：
\[p(x|\mu) = \mu^x (1-\mu)^{1-x}\]这里为了与指数族的参数进行对应写成了这个形式，平常我们在书本中看到的最多的形式是：
\[f(x) =\begin{cases} p, &amp;amp; if &amp;amp; x = 1 \\1-p, &amp;amp; if &amp;amp; x = 0\end{cases}\]很明显是一样的。
伯努利分布可以转换成指数族的标准形式：
\[\begin{aligned}p(x|\mu) &amp;amp; = \exp \left\{ \ln {\mu^x (1-\mu)^{1-x}} \right\} \\&amp;amp; = \exp \left\{ x \ln\mu + (1-x) \ln{(1-\mu)}\right\} \\&amp;amp; = \exp \left\{ x \ln\mu - x \ln{(1-\mu)} + \ln{(1-\mu)}\right\} \\&amp;amp; = \exp \left\{ x \ln{\mu \over {1-\mu}} + \ln{(1-\mu)} \right\} \\&amp;amp; = (1-\mu) \exp \left\{ x \ln{\mu \over {1-\mu}} \right\} \end{aligned}\]于是有</description>
    </item>
    
    <item>
      <title>R语言的字符串处理</title>
      <link>https://fanggong.pub/posts/20210319_stringr/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210319_stringr/</guid>
      <description>对单个字符串进行操作对空格进行操作locale sensitivepattern匹配base R与stringr的性能比较相关包：stringr
根据Introduction to stringr，该包主要包含四种类型的函数：
对字符串进行操作对空格的增加、删除或其他操作locale sensitive：可以理解为针对不同语言输出会不一样的函数pattern匹配函数：支持四种不同的匹配模式，最常用的还是正则表达式对应地，base R中也有相对应的函数达到同样的效果。在各种环境下测试，发现base R中字符串操作函数的性能在数据较大情况下普遍不如stringr。
对单个字符串进行操作此类函数对字符串进行操作，由于每个函数都已被向量化，故可以直接以字符串向量为参数
str_length()返回字符串长度
str_length(c(&amp;quot;fang&amp;quot;, &amp;quot;方&amp;quot;, NA_character_))## [1] 4 1 NAbase R中使用nchar()函数
nchar(c(&amp;quot;fang&amp;quot;, &amp;quot;方&amp;quot;, NA_character_))## [1] 4 1 NAstr_sub()返回和替换字符串子串
string &amp;lt;- c(&amp;quot;fang yongchao&amp;quot;, &amp;quot;stringr&amp;quot;)str_sub(string, start = 1, end = 4)## [1] &amp;quot;fang&amp;quot; &amp;quot;stri&amp;quot;str_sub(string, start = 1, end = 4) &amp;lt;- &amp;quot;?</description>
    </item>
    
    <item>
      <title>R的面向对象编程</title>
      <link>https://fanggong.pub/posts/20210313_object_oriented/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210313_object_oriented/</guid>
      <description>基础类型S3定义类和创建对象定义新的泛型函数定义新的方法S4定义类和创建对象定义新的泛型函数定义新的方法RC定义类和创建对象定义类的方法类的继承R6定义类、方法和创建对象Active binding类的继承基础类型最常见的基础类型就是向量和列表同时基础类型还包括函数、环境和其他更独特的对象S3目前使用的大部分对象都是S3对象在S3中，方法属于泛型函数，一个泛型函数会有多个方法，可以用methods()来查看泛型函数的方法S3并不需要一个正式的类定义，需要的仅仅是一个构造函数data.frame是一个S3对象
df &amp;lt;- data.frame(x = 1:3, y = 4:6)pryr::otype(df)## [1] &amp;quot;S3&amp;quot;mean()是一个泛型函数
pryr::ftype(mean)## [1] &amp;quot;s3&amp;quot; &amp;quot;generic&amp;quot;mean.Date()是一个方法
pryr::ftype(mean.Date)## [1] &amp;quot;s3&amp;quot; &amp;quot;method&amp;quot;查看mean()的所有方法
methods(mean)## [1] mean.</description>
    </item>
    
    <item>
      <title>重复测量数据方差分析</title>
      <link>https://fanggong.pub/posts/20210311_repeat_measure_anova/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210311_repeat_measure_anova/</guid>
      <description>数据正态性检验方差齐性检验方差分析球形检验p值校正多重比较、单独效应分析等相关包：car
在这里仅记录重复测量数据方差分析的R语言实现及结果解释，不涉及其原理说明。
重复测量数据的方差分析的步骤大致如下图：
Figure 1: 重复测量数据方差分析流程数据使用下面的代码造一份假数据，50个对象，分成5个处理分组（甲乙丙丁戊），对每个对象进行4次重复测量。
set.seed(2414)dat &amp;lt;- data.frame(ID = gl(50, 1),group = gl(5, 10, labels = c(&amp;quot;甲&amp;quot;, &amp;quot;乙&amp;quot;, &amp;quot;丙&amp;quot;, &amp;quot;丁&amp;quot;, &amp;quot;戊&amp;quot;)),measure_1 = round(rnorm(50, 50), 2),measure_2 = round(rnorm(50, 30), 2),measure_3 = round(rnorm(50, 20), 2),measure_4 = round(rnorm(50, 40), 2))IDgroupmeasure_1measure_2measure_3measure_41甲51.</description>
    </item>
    
    <item>
      <title>用R绘制流程图</title>
      <link>https://fanggong.pub/posts/20210310_diagram/</link>
      <pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210310_diagram/</guid>
      <description>创建空画板规划坐标插入BOX插入ARROW相关包：diagram
原理相当简单，创建一个空的画板，规划坐标，然后在上面插入BOX和ARROW即可。由于是在base R的体系中进行作图，所以有很高的自由度。
创建空画板该函数中有一个asp参数。个人习惯，至少在绘制流程图的时候，将它设为1，这样可以保证在设定BOX的长宽时得到的是一个稳定的图形。
openplotmat(asp = 1)规划坐标elpos &amp;lt;- coordinates(pos = c(1, 2, 3, 4), hor = FALSE)上面的代码将画板划分成了如下形式
插入BOXdiagram包共提供了九种BOX
par(mar = c(0, 0, 0, 0), family = &amp;quot;HannotateSC-W5&amp;quot;)openplotmat(asp = 1)box(col = &amp;quot;#dcdcdc&amp;quot;)elpos &amp;lt;- coordinates(pos = rep(3, 6), hor = FALSE)textdiamond(elpos[3, ], radx = 0.1, rady = 0.1, lab = &amp;quot;临&amp;quot;, cex = 2)text(elpos[6, 1], elpos[6, 2], labels = &amp;quot;textdiamond&amp;quot;)textellipse(elpos[9, ], radx = 0.</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://fanggong.pub/about/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/about/</guid>
      <description>Fang Yongchao，男，90后。
2013年本科毕业于北京理工大学数学系。
2019年研究生毕业于日本筑波大学系统情报工学系。
在此之前主要从事数据分析和相关的项目咨询工作（DS方向）。
目前在某创业公司从事R语言开发工程师工作。爱好健身，剑道初段。
为什么会有这个blog大学期间学习了数学，学习了编程，也那么稍微地学习了一点金融。但是以通过考试为目的的学习的结果就是大多数的东西在考试后就被忘得一干二净。
在研究生入学的准备过程中开始一一捡起曾经丢下的东西，在此期间接触到了RMarkdown，于是各种相关的笔记都以Rmd的形式记录并保存了下来。
最近又接触到了blogdown，同时由于工作上需要了解一些服务器相关知识入手了一个云服务器，进一步的于是有了把之前的笔记整理一遍和之后的学习一起以独立博客形式保存下来的想法。
</description>
    </item>
    
  </channel>
</rss>
