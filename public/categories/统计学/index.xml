<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>统计学 on Fang Yongchao</title>
    <link>https://fanggong.pub/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/</link>
    <description>Recent content in 统计学 on Fang Yongchao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ch</language>
    <lastBuildDate>Mon, 10 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://fanggong.pub/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>极大似然估计(MLE)和最大后验概率估计(MAP)</title>
      <link>https://fanggong.pub/posts/20210510_mle_and_map/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210510_mle_and_map/</guid>
      <description>频率学派与贝叶斯学派极大似然估计(MLE)最大后验概率估计(MAP)频率学派与贝叶斯学派关于频率学派与贝叶斯学派的标准解释网上有很多，下面是个人的一些理解。
频率学派频率学派认为世界是确定的，也即某个事件发生的概率是确定的。在一次试验中无论该事件发生还是不发生都只是其发生概率\(p\)的一次体现而已。所以当进行多次重复试验时，事件发生的次数占总试验次数的比例就会逐渐接近这个事件的发生概率\(p\)。
在上述的前提下，如果想要知道这个\(p\)，那么只需要进行多次试验，然后解出\(p\)的最可能的取值即可。这就是从最初开始学习统计学时就接触到的极大似然估计(MLE)。很显然，在频率学派的方法下，当进行足够多的试验后即积累足够的数据量时我们可以得到一个很接近\(p\)的估计。
贝叶斯学派与频率学派不同，贝叶斯学派认为世界是不确定的，它是随着我们对世界的认知改变的（就感觉很主观，但是又主观得很有道理…）。因此，在贝叶斯学派下，事件发生的概率\(p\)并不是一个确定的数字，根据不同的认知（即先验假设）对\(p\)应该作出不一样的估计，即最大后验概率估计(MAP)。
随着试验次数的增加，我们的先验假设的作用被逐渐淡化，数据中体现的信息将会在估计中占据主导作用，因此当数据量足够大时，会发现两种估计方法会得到相同的结论。
极大似然估计(MLE)以丢硬币为例，丢硬币10次，其中正面朝上7次，反面朝上3次，使用极大似然估计求解正面朝上的概率\(p\)。
有似然函数：\[f(X, p) = P(X|p) = p^7(1-p)^3\]取对数：\[\ln f(X, p) = 7\ln p + 3\ln(1-p) \]求导得到：\[(\ln f(X, p))&amp;#39; = {7p + 3p - 7 \over p(p-1)} = {10p - 7 \over p^2-p}\]令上式等于0可以得到\(p\)等于0.7。即当丢一个硬币10次，其中正面朝上7次，反面朝上3次时，极大似然估计认为正面朝上的概率最可能是0.7。
我们知道一个均匀的硬币正面朝上的概率应该是0.5，所以当数据量较小时，极大似然估计的结果与我们的先验知识就产生了偏差（在数据量大的情况下并不会有这样的问题，因为如果丢一个硬币10000次，正面朝上7000次，反面朝上3000次，那么应该做的是好好查查这个硬币是不是真的是均匀的了）。
最大后验概率估计(MAP)在极大似然估计中我们寻找使得\(P(X|p)\)取到最大值的\(p\)，而在最大后验概率估计中，我们寻找的是使得\(P(X|p)P(p)\)取到最大值的\(p\)。
根据贝叶斯公式有：\[P(X|p)P(p) = P(p|X)P(X)\]这里的\(P(X)\)是一个已知的值（7次正面，3次反面），所以我们要求解的实际是使得\(P(p|X)\)（即后验概率，故称为最大后验概率估计）取到最大值的\(p\)。</description>
    </item>
    
    <item>
      <title>生存分析及R语言实现</title>
      <link>https://fanggong.pub/posts/20210406_survival_analysis/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210406_survival_analysis/</guid>
      <description>相关概念Kaplan-Meier方法Log-rank检验Cox比例风险回归模型相关包：survival，survminer
相关概念生存分析主要用于分析感兴趣的事件发生所需要的时间以及变量对事件发生的影响。
有如下几个相关概念：
事件（Event）：比如在癌症相关研究中，病人的死亡
时间（Time）：当事件没有发生时，时间就是起始时间到当前时间的跨度，当事件发生时，时间为起始时间到事件发生的时间跨度
删失（Censoring）：个人认为这个概念没必要过度理解，截止到某时间点事件没有发生，即为删失（这个时间点可能是当前时间，也可能是失去调查对象数据的中间某个时间点）
生存函数（Survival Function）：一般写作\(S(t)\)，表示从起始时间到时间t没有发生事件的概率，即：\[S(t) = P \left( T &amp;gt; t \right)\]
寿命分布函数（Lifetime distribution function）：一般写作\(F(t)\)，表示从起始时间到时间t发生了事件的概率，即：\[F(t) = P \left( T \le t \right) = 1 - S(t)\]
危险函数（Harzard Function）：一般写作\(h(t)\)或\(\lambda(t)\)，表示在截止到时间t事件都没有发生的条件下，事件接下来发生的瞬时概率，即：\[h(t) = \lim_{\Delta t \to 0} {P(t \le T \lt t + \Delta t\,|\, T &amp;gt; t) \over {\Delta t}} = {F&amp;#39;(t) \over S(t)} = - {S&amp;#39;(t) \over S(t)}\]</description>
    </item>
    
    <item>
      <title>关于指数族的定义</title>
      <link>https://fanggong.pub/posts/20210322_exponential_family/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210322_exponential_family/</guid>
      <description>指数分布族伯努利分布的指数族形式正态分布的指数族形式分类分布的指数族形式指数分布族的概念主要应用于广义线性模型（GLM）。
指数分布族指数分布族（exponential family）的分布可以写成如下形式：
\[p(x|\eta) = h(x) g(\eta) \exp \left\{\eta^Tu(x)\right\}\]
\(\boldsymbol {\eta}\)为自然参数，是决定分布的具体参数\(\boldsymbol {u(x)}\)称作充分统计量，通常有\(\boldsymbol {u(x) = x}\)\(\boldsymbol {g(\eta)}\)称作分布正规化系数，为确保概率和为1伯努利分布的指数族形式伯努利分布的一般形式可以写为：
\[p(x|\mu) = \mu^x (1-\mu)^{1-x}\]这里为了与指数族的参数进行对应写成了这个形式，平常我们在书本中看到的最多的形式是：
\[f(x) =\begin{cases} p, &amp;amp; if &amp;amp; x = 1 \\1-p, &amp;amp; if &amp;amp; x = 0\end{cases}\]很明显是一样的。
伯努利分布可以转换成指数族的标准形式：
\[\begin{aligned}p(x|\mu) &amp;amp; = \exp \left\{ \ln {\mu^x (1-\mu)^{1-x}} \right\} \\&amp;amp; = \exp \left\{ x \ln\mu + (1-x) \ln{(1-\mu)}\right\} \\&amp;amp; = \exp \left\{ x \ln\mu - x \ln{(1-\mu)} + \ln{(1-\mu)}\right\} \\&amp;amp; = \exp \left\{ x \ln{\mu \over {1-\mu}} + \ln{(1-\mu)} \right\} \\&amp;amp; = (1-\mu) \exp \left\{ x \ln{\mu \over {1-\mu}} \right\} \end{aligned}\]于是有</description>
    </item>
    
    <item>
      <title>重复测量数据方差分析</title>
      <link>https://fanggong.pub/posts/20210311_repeat_measure_anova/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fanggong.pub/posts/20210311_repeat_measure_anova/</guid>
      <description>数据正态性检验方差齐性检验方差分析球形检验p值校正多重比较、单独效应分析等相关包：car
在这里仅记录重复测量数据方差分析的R语言实现及结果解释，不涉及其原理说明。
重复测量数据的方差分析的步骤大致如下图：
Figure 1: 重复测量数据方差分析流程数据使用下面的代码造一份假数据，50个对象，分成5个处理分组（甲乙丙丁戊），对每个对象进行4次重复测量。
set.seed(2414)dat &amp;lt;- data.frame(ID = gl(50, 1),group = gl(5, 10, labels = c(&amp;quot;甲&amp;quot;, &amp;quot;乙&amp;quot;, &amp;quot;丙&amp;quot;, &amp;quot;丁&amp;quot;, &amp;quot;戊&amp;quot;)),measure_1 = round(rnorm(50, 50), 2),measure_2 = round(rnorm(50, 30), 2),measure_3 = round(rnorm(50, 20), 2),measure_4 = round(rnorm(50, 40), 2))IDgroupmeasure_1measure_2measure_3measure_41甲51.</description>
    </item>
    
  </channel>
</rss>
